export OGBDataset

using DataDeps
using DelimitedFiles: readdlm

function __init__ogbdataset()
    DEPNAME = "OGBDataset"
    LINK = "http://snap.stanford.edu/ogb/data"
    DOCS = "https://ogb.stanford.edu/docs/dataset_overview/"
    
    register(DataDep(
        DEPNAME,
        """
        Dataset: The $DEPNAME dataset.
        Website: $DOCS
        Download Link: $LINK
        """,
        "$LINK",
        # "7433f55a5ac51029dfdc6bf9ba58902be454413de0867ced8c57c62ad51e9107",  # if checksum omitted, will be generated by DataDeps
    ))
end

struct OGBDataset
    name::String
    path::String
    num_nodes::Int
    num_edges::Int
    num_graphs::Int
    source::Vector{Int}
    target::Vector{Int}
    graph_indicator
    node_labels::Union{Nothing, Vector{Int}}
    edge_labels::Union{Nothing, Vector{Int}}
    graph_labels
    node_attributes
    edge_attributes
    graph_attributes
end

"""
    OGBDataset(name; dir=nothing)
"""
function OGBDataset(fullname; dir=nothing)
    d = datadir_ogbdataset(fullname, dir)
    prefix, name = split(fullname, "-")
    path = joinpath(datadep"OGBDataset", name)

    
    function read_ogb(p, T; tovec=false, transp=true)
        res = isfile(p) ? read_csv(p, Matrix{T}, header=false) : nothing
        # @show p typeof(res)
        if tovec && res !== nothing
            @assert size(res, 1) == 1 || size(res, 2) == 1
            res = vec(res)
        end
        if transp && res !== nothing && !tovec
            res = collect(res')
        end
        return res
    end
    
    dict = Dict{String, Any}()

    dict["edge_index"] = read_ogb(joinpath(path, "raw", "edge.csv"), Int, transp=false)
    dict["edge_index"] = dict["edge_index"] .+ 1 # from 0-indexing to 1-indexing
        
    dict["node_feat"] = read_ogb(joinpath(path, "raw", "node-feat.csv"), Float32)
    dict["node_label"] = read_ogb(joinpath(path, "raw", "node-label.csv"), Int)
    
    dict["num_node_list"] = read_ogb(joinpath(path, "raw", "num-node-list.csv"), Int; tovec=true)
    dict["num_edge_list"] = read_ogb(joinpath(path, "raw", "num-edge-list.csv"), Int; tovec=true)

    for file in readdir(joinpath(path, "raw"))
        if file ∉ ["edge.csv", "num_node_list.csv", "num_edge_list.csv", "node-feat.csv", "node-label.csv"]
            propname = replace(split(file,".")[1], "-" => "_")
            dict[propname] = read_ogb(joinpath(path, "raw", "node-feat.csv"), Any)
        end
    end

    
    splits = readdir(joinpath(path, "split"))
    @assert length(splits) == 1 # TODO check if datasets with multiple splits existin in OGB
    dict["train_idx"] = read_ogb(joinpath(path, "split", splits[1], "train.csv"), Int; tovec=true)
    dict["val_idx"] = read_ogb(joinpath(path, "split", splits[1], "valid.csv"), Int; tovec=true)
    dict["test_idx"] = read_ogb(joinpath(path, "split", splits[1], "test.csv"), Int; tovec=true)
    dict["train_idx"] = dict["train_idx"] .+ 1
    dict["val_idx"] = dict["val_idx"] .+ 1
    dict["test_idx"] = dict["test_idx"] .+ 1

    return dict
end

 function datadir_ogbdataset(fullname, dir = nothing)
    dir = isnothing(dir) ? datadep"OGBDataset" : dir
    @assert contains(fullname, "-") "The full name should be provided, e.g. ogbn-arxiv"
    prefix, name = split(fullname, "-")
    prefix = prefix == "ogbn" ? "nodeproppred" :
             prefix == "ogbl" ? "linkproppred" :
             prefix == "ogbg" ? "graphproppred" : error("wrong prefix")
    LINK = "http://snap.stanford.edu/ogb/data/$prefix/$name.zip"
    d  = joinpath(dir, name)
    if !isdir(d)
        DataDeps.fetch_default(LINK, dir)
        currdir = pwd()
        cd(dir) # Needed since `unpack` extracts in working dir
        DataDeps.unpack(joinpath(dir, "$name.zip"))
        for (root, dirs, files) in walkdir(dir)
            for file in files
                if endswith(file, r"zip|gz")
                    cd(root)
                    DataDeps.unpack(joinpath(root, file))
                end
            end
        end
        cd(currdir)
    end
    @assert isdir(d)
    return d
end

# Base.getindex(data::TUDataset, i::Int) = getindex(data, [i])

# function Base.getindex(data::TUDataset, i::AbstractVector{Int})
#     node_mask = data.graph_indicator .∈ Ref(i)
    
#     nodes = (1:data.num_nodes)[node_mask]
#     node_labels = isnothing(data.node_labels) ? nothing : data.node_labels[node_mask]
#     nodemap = Dict(v => vnew for (vnew, v) in enumerate(nodes))

#     graphmap = Dict(i => inew for (inew, i) in enumerate(i))
#     graph_indicator = [graphmap[i] for i in data.graph_indicator[node_mask]]
    
#     edge_mask = data.source .∈ Ref(nodes) 
#     source = [nodemap[i] for i in data.source[edge_mask]]
#     target = [nodemap[i] for i in data.target[edge_mask]]
#     edge_labels = isnothing(data.edge_labels) ? nothing : data.edge_labels[edge_mask]

#     graph_labels = isnothing(data.graph_labels) ? nothing : data.graph_labels[i]
    
#     node_attributes = isnothing(data.node_attributes) ? nothing : data.node_attributes[:,node_mask]
#     edge_attributes = isnothing(data.edge_attributes) ? nothing : data.edge_attributes[:,edge_mask]
#     graph_attributes = isnothing(data.graph_attributes) ? nothing : data.graph_attributes[:,i]

#     num_nodes = length(graph_indicator)
#     num_edges = length(source)
#     num_graphs = length(i)

#     TUDataset(num_nodes, num_edges, num_graphs,
#             source, target, 
#             graph_indicator,
#             node_labels,
#             edge_labels,            
#             graph_labels,
#             node_attributes, 
#             edge_attributes,
#             graph_attributes)
# end
